# Example code for IMRT100 robot project


# Import some modules that we need
import imrt_robot_serial
import signal
import time
import sys
import random

LEFT = -1
RIGHT = 1
FORWARDS = 1
BACKWARDS = -1
DRIVING_SPEED = 200
TURNING_SPEED = 150
STOP_DISTANCE = 15

TURNING = False
MARGIN = 1
ASSUMED_CHANGE_IN_SIDEDISTANCE_NEAR_SWING = 40

# Lists in which the the two last registered distances for each sensor is stored.

distance_change_front = []
distance_change_left = []
distance_change_right = []
distance_change_back = []

# Function which fills and updates the lists above.

def save_distances(front, left, right, back):
    if len(distance_change_front) > 1 or len(distance_change_left) > 1 or len(distance_change_right) > 1 or len(distance_change_back) > 2:
        distance_change_front.pop()
        distance_change_left.pop()
        distance_change_right.pop()
        distance_change_back.pop()
        
    distance_change_front.append(front)
    distance_change_left.append(left)
    distance_change_right.append(right)
    distance_change_back.append(back)

# Function that(if the robot IS NOT turning) sees if the robot is driving straight, by checking if there is a change in the registered distance of the sidesensors.

def driving_straight():
    change_left = distance_change_left[0] - distance_change_left[1]
    change_right = distance_change_right[0] - distance_change_right[1]
    global TURNING
    if TURNING == False:
        if len(distance_change_front) == 2 or len(distance_change_left) == 2 or len(distance_change_right) == 2 or len(distance_change_back) == 2:
            if (MARGIN > change_left > -MARGIN or change_left) > ASSUMED_CHANGE_IN_SIDEDISTANCE_NEAR_SWING:
                if MARGIN > change_right > -MARGIN or change_right > ASSUMED_CHANGE_IN_SIDEDISTANCE_NEAR_SWING:
                    print("Driving straight relative to path")
        
        
    

def stop_robot(duration):

    iterations = int(duration * 10)

    for i in range(iterations):
        motor_serial.send_command(0, 0)
        time.sleep(0.10)



def drive_robot(direction, duration):

    speed = DRIVING_SPEED * direction
    iterations = int(duration * 10)

    for i in range(iterations):
        motor_serial.send_command(speed, speed)
        time.sleep(0.10)


"""
def turn_robot_random_angle():

    direction = random.choice([-1,1])
    iterations = random.randint(10, 25)

    for i in range(iterations):
        motor_serial.send_command(TURNING_SPEED * direction, -TURNING_SPEED * direction)
        time.sleep(0.10)
"""

def turn_robot_right():

    direction = 1
    iterations = random.randint(10, 25)
    global TURNING
    TURNING = True

    for i in range(iterations):
        motor_serial.send_command(TURNING_SPEED * direction, -TURNING_SPEED * direction)
        time.sleep(0.10)
        if i == (iterations - 1):
            TURNING = False

def turn_robot_left():

    direction = -1
    iterations = random.randint(10, 25)
    global TURNING
    TURNING = True

    for i in range(iterations):
        motor_serial.send_command(TURNING_SPEED * direction, -TURNING_SPEED * direction)
        time.sleep(0.10)
        if i == (iterations - 1):
            TURNING = False


# We want our program to send commands at 10 Hz (10 commands per second)
execution_frequency = 10 #Hz
execution_period = 1. / execution_frequency #seconds


# Create motor serial object
motor_serial = imrt_robot_serial.IMRTRobotSerial()


# Open serial port. Exit if serial port cannot be opened
try:
    motor_serial.connect("/dev/ttyACM0")
except:
    print("Could not open port. Is your robot connected?\nExiting program")
    sys.exit()


# Start serial receive thread
motor_serial.run()


# Now we will enter a loop that will keep looping until the program terminates
# The motor_serial object will inform us when it's time to exit the program
# (say if the program is terminated by the user)
print("Entering loop. Ctrl+c to terminate")
while not motor_serial.shutdown_now :


    ###############################################################
    # This is the start of our loop. Your code goes below.        #
    #                                                             #
    # An example is provided to give you a starting point         #
    # In this example we get the distance readings from each of   #
    # the two distance sensors. Then we multiply each reading     #
    # with a constant gain and use the two resulting numbers      #
    # as commands for each of the two motors.                     #
    #  ________________________________________________________   #
    # |                                                        |  #
    # V                                                           #
    # V                                                           #
    ###############################################################



    # HAVE TO CHANGE TWO OF THE SENSORS, THE FRONT ONE AND THE RIGHT ONE


    # Get and print readings from distance sensors
    dist_left = motor_serial.get_dist_left()
    dist_behind = motor_serial.get_dist_behind()
    dist_right = motor_serial.get_dist_right()
    dist_ahead = motor_serial.get_dist_ahead()
    print("Dist. left:", dist_left, "   Dist. behind:", dist_behind, "   Dist. right:", dist_right, "   Dist. ahead:", dist_ahead)

    # Check if there is an obstacle in the way
"""
    if dist_1 < STOP_DISTANCE or dist_2 < STOP_DISTANCE or dist_:
        # There is an obstacle in front of the robot
        # First let's stop the robot for 1 second
        print("Obstacle!")
        stop_robot(1)

        # Reverse for 0.5 second
        drive_robot(BACKWARDS, 0.5)

        # Turn random angle
        turn_robot_random_angle()
"""
    # If there is an obstacle on the right hand side

    save_distances(dist_ahead, dist_left, dist_right, dist_behind)

    driving_straight()
    
    if dist_right < STOP_DISTANCE:
        print("Obstacle right hand side, turning left...")
        stop_robot(1)

        drive_robot(BACKWARDS, 0.5)

        turn_robot_left()

    # If there is an obstacle on the left hand side
    elif dist_left < STOP_DISTANCE:
        print("Obstacle left hand side, turning right...")
        stop_robot()

        drive_robot(BACKWARDS, 0.5)

        turn_robot_right()


    else:
        # If there is nothing in front of the robot it continus driving forwards
        drive_robot(FORWARDS, 0.1)







    ###############################################################
    #                                                           A #
    #                                                           A #
    # |_________________________________________________________| #
    #                                                             #
    # This is the end of our loop,                                #
    # execution continus at the start of our loop                 #
    ###############################################################
    ###############################################################





# motor_serial has told us that its time to exit
# we have now exited the loop
# It's only polite to say goodbye
print("Goodbye")
